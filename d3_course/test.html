
<html>
	<head>
		<title>Site</title>

		<!-- <link rel="stylesheet" href="styles.css" /> -->
		<!-- this could be standalone CSS using line above to source -->
		<style>
			p {
				color: black;
				padding: 10px;
			}

			h1:hover{
				color:green;
			}

			button:hover{
				background-color: blue;
				color: red;
			}

			.line{      /* for line plot */
				fill: none;
				stroke: lightblue;
			}

			#tooltip{      
				color: green;
				position: absolute;     /* makes it possible to move the text around */
				border: 1px black solid;
				padding: 10px;
				background-color: white;
				display: none;      /* starts off hidden */
				'top': 200)
				'left': 200)
			}



		</style>

	</head>
	<body>


		<svg style="border:solid 1px black;">   <!-- Making a box -->
			<g transform='translate (50, 50) rotate(30)'>    <!-- Moves those in the group 50px right and down -->
				<rect x=20 y =20 width=50 height = 50 />
				<circle r=20 cx=50 cy = 50 fill='red'/>     <!-- Radius, and where centre is -->
				<text>Yo yo</text>
			</g>
		</svg>


		<ul id=itemlist>
			<li>item1</li>
			<li>item2</li>
		</ul>

		<div id="pageheader">  <!-- giving header an id - makes it easier for d3 to call -->
			<h1>Welcome</h1>
		</div>

		<p style="background-color: #CCDDEE;">Please enter info</p>       <!-- inline highlighting -->
		<div> Name: <input /></div>
		<div>DoB: <input type="date" /></div>   <!-- date selector box -->
		<button onclick="change1()">Update name</button>   <!-- runs function change1() on click -->

		<button onclick="change2()">add item</button>
		<button onclick="change3()">remove item</button>
		<button onclick="change4()">remove all items</button>
		<button onclick="change_welcome_col()">Change title colour</button>

		<button onclick="change_animal()">Change animal</button>
		<div>
			<img id = 'animalImg' src='doge.jpeg'>
		</div>

		<div id = 'container'>   <!-- to view d3 output -->
		</div>

		<div id = 'contain2'>   <!-- to view d3 output -->
		</div>

		<br>
		<button onclick="addclient()">add client</button>
		<br>

		<br>
		<button onclick="write_chart()">write_chart</button>
		<br>

		<div id = 'contain_chart'>   <!-- to view d3 output -->
		</div>


		<svg id = 'line' height = 300 width = '50%', style="border:solid 1px black;">   <!-- to view output in svg -->
			<g id = 'linebody' style='transform: translate(50px, 0px);'></g>  
		</svg>

		<svg id = 'pie' height = 300 width = '50%', style="border:solid 1px black;">   <!-- to view output in svg -->
			<g id = 'piebody' style='transform: translate(100px, 100px);'></g>  
		</svg>

		<svg id = 'map' height = 400 width = '50%', style="border:solid 1px black;">   <!-- to view output in svg -->
			<g id = 'mapbody'></g>  
		</svg>

		<svg id = 'map_camden' height = 400 width = '50%', style="border:solid 1px black;">   <!-- to view output in svg -->
			<g id = 'mapbody_camden'></g>  
		</svg>

		<svg id = 'map_linked' height = 400 width = '50%', style="border:solid 1px black;">   <!-- to view output in svg -->
			<g id = 'mapbody_linked'></g>  
		</svg>

		<svg id = 'net' height =400 width = '52%', style="border:solid 1px black;">   <!-- to view output in svg -->
			<g id = 'netwerq'></g>  
		</svg>

		<svg id = 'contain_cats_listener' height = 300 width = '49%', style="border:solid 1px black;">   <!-- to view output in svg -->
			<g id = 'listener' style='transform: translate(50px, 0px);'></g>  <!-- calls contain_cats  -->
			<g id = 'yAxisl'></g>
			<g id = 'xAxisl'></g>
		</svg>

		<svg id="my_dataviz" height = 400 width = '49%', style="border:solid 1px black;"></svg>


		<div id = 'hover_name'>
			Name tbc...
		</div>

		<div id = 'details'>
			User details...
		</div>

		<select id="selectButton"></select>
		<div>   Select for choropleth: </div>
		<select id="selectChoropleth"></select>
		<br>




		<svg id = 'mapbody_interactive_head' height = 400 width = '49%', style="border:solid 1px black;">   <!-- to view output in svg -->
			<g id = 'mapbody_interactive' style='transform: translate(0px, 0px);'></g>  <!-- calls contain_cats  -->
			<g id = 'yAxisl'></g>
			<g id = 'xAxisl'></g>
		</svg>



		<svg id = 'call' height = 400 width = '49%', style="border:solid 1px black;">   <!-- to view output in svg -->
			<g id = 'callback_plot' style='transform: translate(0px, 0px);'></g>  <!-- calls contain_cats  -->
		</svg>



		<div id = 'tooltip'>Tooltip</div>

		<div id = 'map_text'>
			LSOA info....
		</div>





	</body>


	<script src="https://d3js.org/d3.v6.js"></script>  

	<script>




		/// interactive force network
		let net_data2 = {
			'nodes': [
				{'id': 'john'},
				{'id': 'adam'},
				{'id': 'jane'}
			],

			'links': [
				{'source': 'john', 'target': 'adam'},
				{'source': 'john', 'target': 'jane'},
				{'source': 'jane', 'target': 'adam'}
			]
		}

		/// static force network
		var margin = {top: 10, right: 30, bottom: 30, left: 40},
		  width = 400 - margin.left - margin.right,
		  height = 400 - margin.top - margin.bottom;

		// append the svg object to the body of the page
		var svg = d3.select("#my_dataviz")
		.append("svg")
		  .attr("width", width + margin.left + margin.right)
		  .attr("height", height + margin.top + margin.bottom)
		.append("g")
		  .attr("transform",
		        "translate(" + margin.left + "," + margin.top + ")");

		//d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/data_network.json").then(make_net)


		make_net(net_data2)

		function make_net(data) {

			console.log(data)

		  // Initialize the links
		  var link = svg
		    .selectAll("line")
		    .data(data.links)
		    .enter()
		    .append("line")
		      .style("stroke", "#aaa")

		  // Initialize the nodes
		  var node = svg
		    .selectAll("circle")
		    .data(data.nodes)
		    .enter()
		    .append("circle")
		      .attr("r", 20)
		      .style("fill", "#69b3a2")

		  // Let's list the force we wanna apply on the network
		  var simulation = d3.forceSimulation(data.nodes)                 // Force algorithm is applied to data.nodes
		      .force("link", d3.forceLink()                               // This force provides links between nodes
		            .id(function(d) { return d.id; })                     // This provide  the id of a node
		            .links(data.links)                                    // and this the list of links
		      )
		      .force("charge", d3.forceManyBody().strength(-400))         // This adds repulsion between nodes. Play with the -400 for the repulsion strength
		      .force("center", d3.forceCenter(width / 2, height / 2))     // This force attracts nodes to the center of the svg area
		      .on("end", ticked);

		  // This function is run at each iteration of the force algorithm, updating the nodes position.
		  function ticked() {
		    link
		        .attr("x1", function(d) { return d.source.x; })
		        .attr("y1", function(d) { return d.source.y; })
		        .attr("x2", function(d) { return d.target.x; })
		        .attr("y2", function(d) { return d.target.y; });

		    node
		         .attr("cx", function (d) { return d.x+6; })
		         .attr("cy", function(d) { return d.y-6; });
		  }

		};
















		// populate values for choropleth dropdown menus
		var allGroup = ["trends", "other_trends"]
		d3.select("#selectButton")
		      .selectAll('myOptions')
		     	.data(allGroup)
		      .enter()
		    	.append('option')
		      .text(function (d) { return d; }) // text showed in the menu
		      .attr("value", function (d) { return d; })

		var allGroup = ['reverse_air_quality_indicator', "air_quality_indicator"]
		d3.select("#selectChoropleth")
		      .selectAll('myOptions')
		     	.data(allGroup)
		      .enter()
		    	.append('option')
		      .text(function (d) { return d; }) // text showed in the menu
		      .attr("value", function (d) { return d; })  





		// line graph for callback
		let callback_plot = d3.select('#callback_plot')

		function drawLineChart(selectedTrends) {

			callback_plot.selectAll("*").remove();  // deleting previous chart

			let bodyHeight = 400
			let bodyWidth = 400

			var margin = {top: 30, right: 30, bottom: 30, left: 50}
				  , width = bodyWidth - margin.left - margin.right // Use the window's width 
				  , height = bodyHeight - margin.top - margin.bottom; // Use the window's height


			// creating functions to scale values
			var xScale = d3.scaleLinear()
			    .domain([2015, 2019]) // input
			    .range([0, width]); // output

		    var yScale = d3.scaleLinear()
			    .domain([d3.min(selectedTrends), d3.max(selectedTrends)]) // input 
			    .range([height, 0]); // output 

			 		
			// scaling x and y values to pixel positions
			let years  = [2015, 2016, 2017, 2018, 2019]
			let years_scaled = years.map(d => xScale(d))
			let trends_scaled = selectedTrends.map(d => yScale(d))
			

			// making array of x/y array pairs years and crime numbers
			let figure_arrays = []
			for (let i = 0; i < years.length; i++) {         
				figure_arrays.push([years_scaled[i], +trends_scaled[i]])
			}

			// will generate path for line
			var Gen = d3.line(); 
			var pathOfLine = Gen(figure_arrays); 


			var svg = callback_plot.append("svg")
			    .attr("width", width + margin.left + margin.right)
			    .attr("height", height + margin.top + margin.bottom)
			    .append("g")
			    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			 // 3. Call the x axis in a group tag
			svg.append("g")
			    .attr("class", "x axis")
			    .attr("transform", "translate(0," + height + ")")
			    .call(d3.axisBottom(xScale)); // Create an axis component with d3.axisBottom

			 // 4. Call the y axis in a group tag
			svg.append("g")
			    .attr("class", "y axis")
			    .call(d3.axisLeft(yScale)); // Create an axis component with d3.axisLeft

			 // add the line
		   svg.append('path') 
   				.attr('class', 'line')
    			.attr('d', pathOfLine)
    			.attr("stroke", "red")
                .attr("stroke-width", 4)


	    	//// add zoom: doesn't work atm
	    	let zoom = d3.zoom()
	    	zoom.on('zoom', function() {
	    		console.log(event, event.transform)
	    		let newXScale = event.transform.rescaleX(xScale)  
	    		let newYScale = event.transform.rescaleY(yScale)  

	    		xAxis.scale(newXScale)
	    		xAxisGroup.group(xAxis)

	    		yAxis.scale(newYScale)
	    		yAxisGroup.group(yAxis)
	    	})
	    	let container = d3.select('#call')
	    	container.call(zoom)


		}




		/////// Interactive camden choropleth, inc zooming and callbacks (calls drawLineChart())
		let mapbody_interactive = d3.select('#mapbody_interactive')

		/*
		let all_choropleth_data = Promise.all([
					d3.csv('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/imd_pop_lsoa.csv'),
					d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys_noid.json'),
					d3.csv('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/lsoa_crimes.csv')
				])

		let val_in = d3.select("#selectChoropleth").property("value")
		console.log(all_choropleth_data)

		let choro_data = []
		choro_data.push(d3.csv('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/imd_pop_lsoa.csv'))
		choro_data.push(d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys_noid.json'))
		choro_data.push(d3.csv('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/lsoa_crimes.csv'))
		console.log(all_choropleth_data)
		show_map_data_interactive(choro_data)
		*/


		const zoom = d3.zoom()     // func to enable zoom
    		.on('zoom', (event) => {
		      //g.attr('transform', event.transform);
		      g.attr('transform', event.transform);
		      //console.log(event.transform.k)
		      //revealText(k = event.transform.k)     // changes which text is revealed based on zoom level
		    })
		    //.scaleExtent([0.5, 100]);   // magnification from 0.5x to 100x



		// ensuring nothing is done until all files are loaded
		Promise.all([
			d3.csv('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/imd_pop_lsoa.csv'),
			d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys_noid.json'),
			d3.csv('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/lsoa_crimes.csv')
		]).then(show_map_data_interactive)
		
		var global_dataset;
		

		function show_map_data_interactive(dataSources) {

			mapbody_interactive.selectAll("*").remove();  // deleting previous chart


			global_dataset = dataSources;  // making it globally available 




			

			let mapInfo = dataSources[1]
			let data = dataSources[0]
			let lsoa_trends = dataSources[2]

			let selected_value = d3.select("#selectChoropleth")
				.call(zoom)   // does nothing atm
				.property("value")


			console.log(selected_value)

			let dataIndex = {}
			for (let c of data) {         // making key/value pair of lsoa code and air quality numbers
				let lsoa = c['LSOA Code']
				dataIndex[lsoa] = +c.air_quality_indicator
			}

			let reverseDataIndex = {}
			for (let c of data) {         // making key/value pair of lsoa code and air quality numbers
				let lsoa = c['LSOA Code']
				reverseDataIndex[lsoa] = 3 - +c.air_quality_indicator
			}



			let trendIndex = {}
			for (let c of lsoa_trends) {         // to add 2nd csv trend columns
				let lsoa = c['lsoa_code']
				trendIndex[lsoa] = [+c['2015'], +c['2016'], +c['2017'], +c['2018'], +c['2019']] 
			}

			let  reverseIndex = {}			// to populate 2nd dropdown ('other trends'), which is passed to callback
			for (let c of lsoa_trends) {         
				let lsoa = c['lsoa_code']
				reverseIndex[lsoa] = [+c['2019'], +c['2018'], +c['2017'], +c['2016'], +c['2015']] 
			}


			mapInfo.features = mapInfo.features.map(d => {
				let lsoa = d.properties.lsoa_code
				d.properties.air_quality_indicator = dataIndex[lsoa]
				d.properties.reverse_air_quality_indicator = reverseDataIndex[lsoa]
				d.properties.trends = trendIndex[lsoa]
				d.properties.other_trends = reverseIndex[lsoa]
				return d;
			})

			// console.log(mapInfo)

			// scaling values for choropleth shading
			let maxAir = d3.max(mapInfo.features, d => d.properties[selected_value])
			console.log(maxAir)

			let cScale = d3.scaleLinear()
				.domain(d3.extent(mapInfo.features, d => d.properties[selected_value]))  // extent() finds min and max vals
				.range(['white', 'blue'])

			//console.log('properties')
			//console.log(mapInfo.features[0].properties)

			let bodyHeight = 400
			let bodyWidth = 400


			let Projection = d3.geoMercator()  // set projection
				.translate([bodyWidth / 2, bodyHeight / 2])   // setting midpoint to centre of box
				.scale(80)                 // zoom level (higher is further out)

			let path = d3.geoPath()
				.projection(Projection)    // initial path


			/// getting bounds, centre point, scale
			let bounds = path.bounds(mapInfo);

			var scale = 75  // this is needed in addition to the scale adjustment below

			var hscale  = scale*bodyWidth  / (bounds[1][0] - bounds[0][0]);
		    var vscale  = scale*bodyHeight / (bounds[1][1] - bounds[0][1]);
		    var scale   = (hscale < vscale) ? hscale : vscale;
		    var offset  = [bodyWidth - (bounds[0][0] + bounds[1][0])/2,
                        bodyHeight - (bounds[0][1] + bounds[1][1])/1];

            center= d3.geoCentroid(mapInfo)   // gets midpoint

		    // updating projection to centre over certain area, scale and offset
		    Projection = d3.geoMercator()
		        .center(center)
		        .scale(scale)
		        .translate(offset)


		    path = path.projection(Projection)


		    console.log('about to change')
		    console.log(mapInfo.features[0].properties[selected_value])

			mapbody_interactive.selectAll('path')
				.data(mapInfo.features)   // selecting features key from geojson
				.enter().append('path')        // add new path for each datapoint
				.attr('d', d => path(d))
				.attr('stroke', 'black')      // boundary cols
				.attr('fill', 
					d => d.properties[selected_value] ?        // tests if value is missing
						cScale(d.properties[selected_value]): 	// uses colour scale if not missing
						'red'                                    
					)

		    	// can only have one func to update a particular obj on mouseover, so put all changes to make in there
		    	.on('mouseover', function(d) {       
		    		this.style.fill ='red',
		    		this.style.stroke = 'yellow',
		    		d3.select(id = '#map_text').html(
		    			d.target.__data__.properties.lsoa_code + ' has air quality of:<br>' + d.target.__data__.properties.air_quality_indicator + ' (lower is better)'
		    		),
		    		showTooltip(d.target.__data__.properties.lsoa_code + ' <br> ' + d.target.__data__.properties.air_quality_indicator + ' <br> ' + d.target.__data__.properties.reverse_air_quality_indicator + '<br>' + d.target.__data__.properties[selected_value] + '<br>Selected val: ' + selected_value,
		    			d3.pointer(event))
		    		selectedLSOA = d.target.__data__.properties.lsoa_code,   // passed to line plot

		    		// extracting the array named in the dropdown menu 
		    		selectedTrends = d.target.__data__.properties[d3.select("#selectButton").property("value")]
		    		drawLineChart(selectedTrends)
		    	})

		    	.on('mousemove', function(d) {   // makes tooltip follow mouse even if highlighted thing doesn't change
		    		showTooltip(d.target.__data__.properties.lsoa_code + ' <br>Air qual: ' + d.target.__data__.properties.air_quality_indicator + ' <br>Rev air qual: ' + d.target.__data__.properties.reverse_air_quality_indicator + '<br>Selected: ' + d.target.__data__.properties[selected_value] + '<br>Selected val: ' + selected_value,
		    			d3.pointer(event))
		    	})

		    	.on('mouseout', function(d) {       // action on unhover
		    		this.style.fill = cScale(d.target.__data__.properties[selected_value])
		    		this.style.stroke = 'black',
		    		d3.select(id = '#map_text').html('<br><br>'),
		    		d3.select('#tooltip').style('display', 'none')
		    	})

		    	.merge(mapbody_interactive.enter())		   // think this is required for callback to line plot

		}



		function showTooltip(text, coords) {

			//callback_plot._parents[0].clientHeight  // returns distance in px to bottom of element from top of page
			let px_from_top_of_page = (+coords[1] + +callback_plot._parents[0].clientHeight - 470)
			d3.select('#tooltip').html(text)
				.style('top', px_from_top_of_page) 
				.style('left', coords[0] + 30)
				.style('display', 'block')  // changes css to make text visible
		}



		  /// Update map whenever dropdown option changes (ideally would do this without redownloading the data)
		    d3.select("#selectChoropleth").on("change", function(d) {
		    	//show_map_data_interactive(all_choropleth_data)
				Promise.all([
					d3.csv('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/imd_pop_lsoa.csv'),
					d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys_noid.json'),
					d3.csv('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/lsoa_crimes.csv')
				]).then(show_map_data_interactive)
		    })
	








	    let inputs = [
	      { name:'adam', height:14, weight:1 },
	      { name:'ben', height:16, weight:2 },
	      { name:'fran', height:3, weight:3  }
	    ]


		///// making bar graph with highlighting and moveable line
		let listener = d3.select('#listener')

    	function showData_listen(inputs) {    // to display clients dict like file
			let max = d3.max(inputs,
		    	d => d.height)

		    let widthScale = d3.scaleLinear()
		    	.range([0, 300])
		    	.domain([0, max])

		    let positionScale = d3.scaleBand()
		    	.range([0, 200])                   // chart will be 200 px high
		    	.domain(inputs.map(d => d.name))   // taking names of inputs as category labels
		    	.padding(0.3)      // padding between bars

		    let join = listener.selectAll('rect')
		    	.data(inputs)



		    // static line
		    let line = d3.select('#listener').append('g')
		    	.attr('transform', 'translate(0, 0)')
		    line.append('line')
		    	.attr('x1', 0)
		    	.attr('y1', 0)
		    	.attr('x2', 0)
		    	.attr('y2', 200)
		    	.attr('stroke', 'red')
		    	.attr('stroke-width', '3px')


		    /// making line move with mouse
		    // change from #contain_cats_listener to #listener to only move line when a bar is highlighted
		    d3.select('#contain_cats_listener').on('mousemove', d => {
		    	let x_pos = d3.pointer(event)[0]    // [1] would get y position of mouse
		    	line.attr('transform', 'translate(' + (x_pos - 50) + ', 0)')
		    })



		    // rect with mouseover effects (putting code this after the creation of line above
		    // means the bar appears over the line and highlighting is preserved)
		    join.enter()
		    	.append('rect')
		    	.attr('fill', 'blue')
		    	.attr('width', d => widthScale(d.height))
		    	.attr('height', positionScale.bandwidth())    // makes bars fill available space
		    	.attr('y', d => positionScale(d.name))

		    	//.on('click', d => {console.log(d.target.__data__['name'])})

		    	.on('click', d => {       // updating text on click
		    		d3.select(id = '#details').text(d.target.__data__['name'] + ', Height: ' + d.target.__data__['height'])    // select text
		    	})

		    	// can only have one func to update a particular obj on mouseover, so put all changes to make in there
		    	.on('mouseover', function(d) {       
		    		d3.select(id = '#hover_name').text(d.target.__data__['name'] + ', BMI: ' + d.target.__data__['bmi'])    // select text
		    		this.style.fill ='red'
		    	})

		    	.on('mouseout', function() {       // action on unhover
		    		this.style.fill ='blue'
		    		d3.select(id = '#hover_name').html('<br>')   // so no text shows when nothing is highlighted
		    	})
				


		    // making x labs using scaled values and positioning directly below chart
		    let xAxis = d3.axisBottom(widthScale)
		    	.ticks(6)
		    	.tickFormat(d => d + ' cm')     // add units to xlab
		    d3.select('#xAxisl')
		    	.attr('transform', 'translate(50, 200)')
		    	.call(xAxis)

		    let yAxis = d3.axisLeft(positionScale)   // same for y axis
		    d3.select('#yAxisl')
		    	.attr('transform', 'translate(50, 0)')
		    	.call(yAxis)



			}
		showData_listen(inputs)








		/// network diagram: displaying very small in the top left right now
		
		let netwerq = d3.select('#netwerq')

		// network
		let net_data = {
			'nodes': [
				{'id': 'john'},
				{'id': 'adam'},
				{'id': 'jane'}
			],

			'links': [
				{'source': 'john', 'target': 'adam'},
				{'source': 'john', 'target': 'jane'},
				{'source': 'jane', 'target': 'adam'}
			]
		}


		function create_elements(data){       // makes graphics 
			let nodes = netwerq.append('g')
				.attr('class', 'nodes')
				.selectAll('circle')
				.data(data.nodes)
				.enter()
				.append('circle')
					.attr('r', 30)
					.attr('fill', 'green')

			let links = netwerq.append('g')
				.attr('class', 'links')
				.selectAll('line')
				.data(data.links)
				.enter()
				.append('line')
		}


		function update_elements(data) {

			d3.select('nodes')
				.selectAll('circle')
				.attr('cx', d => d.x)
				.attr('cy', d => d.y)

			d3.select('links')
				.selectAll('line')
				.attr('x1', d => d.source.x)
				.attr('y1', d => d.source.y)
				.attr('x2', d => d.target.x)
				.attr('y2', d => d.target.y)
		}


		function show_net(data){

			let bodyHeight = 400
			let bodyWidth = 400


			create_elements(data)


			let simulation = d3.forceSimulation()                  // making a simulation which will run a certain number of times
																	// & gets position and velocity at each step
				.force('link', d3.forceLink().id((d) => d.id))      // adding 3 forces, which all act at once
				.force('charge', d3.forceManyBody())
				.force('centre', d3.forceCenter(bodyWidth / 2, bodyHeight / 2)) 

			simulation.nodes(data.nodes)    
				.on('tick', update_elements) /*d => {    // calls update_elements on each tick
					console.log(data)   // view simulation results
				}) 
				.on('tick', d => {    
					console.log(data)   // view simulation results
				}) 
*/ 
			simulation.force('link').links(data.links)



		}
		show_net(net_data)
		








		// camden choropleth (this joins csv and json file)
		let mapbody_linked = d3.select('#mapbody_linked')

		// ensuring nothing is done until both files are loaded
		Promise.all([
			d3.csv('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/imd_pop_lsoa.csv'),
			d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys_noid.json')
		]).then(show_map_data_linked)


		function show_map_data_linked(dataSources) {

			let mapInfo = dataSources[1]
			let data = dataSources[0]

			let dataIndex = {}
			for (let c of data) {         // making key/value pair of lsoa code and air quality numbers
				let lsoa = c['LSOA Code']
				dataIndex[lsoa] = +c.air_quality_indicator
			}

			mapInfo.features = mapInfo.features.map(d => {
				let lsoa = d.properties.lsoa_code
				let air_quality_indicator = dataIndex[lsoa]
				d.properties.air_quality_indicator = air_quality_indicator
				return d;
			})

			// scaling values for choropleth shading
			let maxAir = d3.max(mapInfo.features, d => d.properties.air_quality_indicator)
						console.log(maxAir)

			let cScale = d3.scaleLinear()
				.domain(d3.extent(mapInfo.features, d => d.properties.air_quality_indicator))  // extent() finds min and max vals
				.range(['white', 'blue'])



			let bodyHeight = 400
			let bodyWidth = 400


			let Projection = d3.geoMercator()  // set projection
				.translate([bodyWidth / 2, bodyHeight / 2])   // setting midpoint to centre of box
				.scale(50)                 // zoom level (higher is further in)

			let path = d3.geoPath()
				.projection(Projection)    // initial path


			/// getting bounds, centre point, scale
			let bounds = path.bounds(mapInfo);

			var scale = 45  // this is needed in addition to the scale adjustment below

			var hscale  = scale*bodyWidth  / (bounds[1][0] - bounds[0][0]);
		    var vscale  = scale*bodyHeight / (bounds[1][1] - bounds[0][1]);
		    var scale   = (hscale < vscale) ? hscale : vscale;
		    var offset  = [bodyWidth - (bounds[0][0] + bounds[1][0])/2,
                        bodyHeight - (bounds[0][1] + bounds[1][1])/2];

            center= d3.geoCentroid(mapInfo)   // gets midpoint

		    // updating projection to centre over certain area, scale and offset
		    Projection = d3.geoMercator()
		        .center(center)
		        .scale(scale)
		        .translate(offset)

		    path = path.projection(Projection)

		    console.log(maxAir)
		    console.log(mapInfo.features)


			mapbody_linked.selectAll('path')
				.data(mapInfo.features)   // selecting features key from geojson
				.enter().append('path')        // add new path for each datapoint
				.attr('d', d => path(d))
				.attr('stroke', 'black')      // boundary cols
				.attr('fill', 
					d => d.properties.air_quality_indicator ?        // tests if value is missing
						cScale(d.properties.air_quality_indicator): 	// uses colour scale if not missing
						'red'											// makes red if missing
					)


			// adding circles (not done)
			mapbody_linked.selectAll('circle')





		}








		// camden map 
		let mapbody_camden = d3.select('#mapbody_camden')
		d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys_noid.json').then(show_map_data_camden)

		function show_map_data_camden(mapInfo) {
			let bodyHeight = 400
			let bodyWidth = 400

			let Projection = d3.geoMercator()  // set projection
				.translate([bodyWidth / 2, bodyHeight / 2])   // setting midpoint to centre of box
				.scale(50)                 // zoom level (higher is further in)

			let path = d3.geoPath()
				.projection(Projection)    // initial path



			/// getting bounds, centre point, scale
			let bounds = path.bounds(mapInfo);

			var scale = 45  // this is needed in addition to the scale adjustment below

			var hscale  = scale*bodyWidth  / (bounds[1][0] - bounds[0][0]);
		    var vscale  = scale*bodyHeight / (bounds[1][1] - bounds[0][1]);
		    var scale   = (hscale < vscale) ? hscale : vscale;
		    var offset  = [bodyWidth - (bounds[0][0] + bounds[1][0])/2,
                        bodyHeight - (bounds[0][1] + bounds[1][1])/2];

            center= d3.geoCentroid(mapInfo)   // gets midpoint

		    // updating projection to centre over certain area, scale and offset
		    Projection = d3.geoMercator()
		        .center(center)
		        .scale(scale)
		        .translate(offset)

		    path = path.projection(Projection)


			mapbody_camden.selectAll('path')
				.data(mapInfo.features)   // selecting features key from geojson
				.enter().append('path')        // add new path for each datapoint
				.attr('d', d => path(d))
				.attr('stroke', 'red')      // boundary cols


		}





		/// map from polygons (commenting to save s3 use)
		/*
		let mapbody = d3.select('#mapbody')

		d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/countries.geojson').then(show_map_data_countries)


		//d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys.json').then(show_map_data)
		//d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys_ordered.json').then(show_map_data)
		//d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys_unnested.json').then(show_map_data)
		//d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys_noid.json').then(show_map_data)
		//d3.json('https://amplify-wildrydes-dev-90718-deployment.s3.eu-west-2.amazonaws.com/camden_polys.geojson').then(show_map_data)

	
		//d3.json('camden_polys.json').then(show_map_data)

		// features: (number): id (string from '0') / properties['lsoa_code'] / geometry['coordinates']

		function show_map_data_countries(mapInfo) {
			let bodyHeight = 400
			let bodyWidth = 400

			let Projection = d3.geoMercator()  // set projection
				.translate([bodyWidth / 2, bodyHeight / 2])   // setting midpoint to centre of box
				.scale(50)                 // zoom level (higher is further in)

			let path = d3.geoPath()
				.projection(Projection)

			mapbody.selectAll('path')
				.data(mapInfo.features)   // selecting features key from geojson
				.enter().append('path')        // add new path for each datapoint
				.attr('d', d => path(d))
				.attr('stroke', 'red')      // boundary cols


			console.log(mapbody)
			console.log(mapInfo.features)


			return mapbody

		}
		*/







		// arcs
		let piebody = d3.select('#piebody')

		let piedata = [
	      { name:'adam', sales:14, weight:1 },
	      { name:'ben', sales:16, weight:2 },
	      { name:'fran', sales:3, weight:3  }
	    ]

		function show_pie_data(data) {
			let bodyHeight = 200
			let bodyWidth = 100

			data = data.map(d => ({
				name: d.name,
				sales: +d.sales
			}))

			let pie = d3.pie()        // gets angles in radians for each metric (start and end angle)
				.value(d => d.sales)

			let colorScale = d3.scaleOrdinal()    // assigning a colour to each name
				.range(d3.schemeCategory10)    // choice of existing colour schemes
				.domain(data.map(d => d.name))

			console.log(colorScale('adam'))

			let arc = d3.arc()
				.outerRadius(bodyHeight / 2)
				//.innerRadius(0)   // for pie
				.innerRadius(bodyHeight / 4)


			let g = piebody.selectAll('.arc')
				.data(pie(data))         // use pie obj to assign radian values
				.enter()
				.append('g')     // in case want to add more labels
			
			g.append('path')     // not sure why 'path' as it's a pie - 'path' may have a more universal meaning
				.attr('d', arc)
				.attr('fill', d => {    // applies colours
					return colorScale(d.data.name)  
				})

		}
		show_pie_data(piedata)








		// read in data and view
		d3.csv("https://raw.githubusercontent.com/jbrownlee/Datasets/master/daily-total-female-births.csv", function(data) {
			//console.log(data)
		})

		// line chart (cols Month and Sales)
		let linebody = d3.select('#linebody')
		d3.csv("https://raw.githubusercontent.com/jbrownlee/Datasets/master/daily-total-female-births.csv").then(show_line_data)

		function show_line_data(data) {
			let bodyHeight = 200
			let bodyWidth = 400

			// converting columns
			data = data.map(d => ({
				Date: new Date(d.Date),   // ensuring date input is recognised as date obj
				Births: +d.Births     // the '+' here makes sure it's interpreted as a number
			}))

			let maxValue = d3.max(data,
		    	d => d.Births)

		    let yScale = d3.scaleLinear()
		    	.range([bodyHeight, 0])   // needs to be this way around for higher numbers to get taller columns
		    	.domain([0, maxValue])

		    linebody.append('g')
		    	.call(d3.axisLeft(yScale))

		    let xScale = d3.scaleTime()
		    	.domain(d3.extent(data, d => d.Date))   // finds the min and max dates
		    	.range([0, bodyWidth])

		    linebody.append('g')
		    	.attr('transform', 'translate(0, '+bodyHeight+')')
		    	.call(d3.axisBottom(xScale))
		    		//.tickFormat(d3.timeFormat('%b'))

		    let valueline = d3.line()   // setting path values
		    	.x(d => xScale(d.Date))
		    	.y(d => yScale(d.Births))
		    	//.defined(d => !!d.Births)     // deals with timeseries values set to zero

		    linebody.append('path')          // adding path to plot
		    	.datum(data)						// adding data from 'data'
		    	.attr('d', valueline)
		    	.attr('class', 'line')       // calling CSS class to make line not fill in 


		}
		//show_line_data(data)






		let contain2 = d3.select('#contain2')
		let clients = [{
			Names: 'Client0'
		}]
		let counter = 1;

		function addclient() {     // adds new client and displays it
			clients.push({Name: 'Client' + counter})
			counter ++ 
			showData(clients)
		}

		function showData(clients) {    // to display clients dict like file
			let join = contain2.selectAll('div').data(clients);
			join.enter().append('div').text(d => d.Name)        // doing (I think): appending where Name isn't already there

			join.text(d => d.Name + ' : Updated')    // changes text for those where Name was already there
		}
		showData(clients)






		let container = d3.select('#container')

		function write(text) {
			container.append('div').text(text)
		}
 


	    let d = d3.mean(inputs,      // get sum/mean/min of a column in inputs
	    	(d) => d.weight)
	    console.log(d) 


	    for (let client of inputs) {    
	    	write(client.name)        // sends values to #container, which shows them in html
	    }


		inputs.sort(function(a, b) {   // orders inputs by weight - does this inplace
			return d3.descending(a.weight, b.weight)
		})

		console.log(inputs)    // can see bmi column even though code to create it comes later
  
		for (let client of inputs) {    
	    	write(client.name)        // sends values to #container, which shows them in html
	    }


	    inputs.map( function(client) {    // calculating new column 'bmi': this adds the col inplace
			return client.bmi = client.weight / client.height;
		})

		// adding bmi column to inputs (not needed as are added inplace)
		/*for (let i = 0; i < inputs.length; i++) {
			inputs[i]['bmi'] = bmi[i] 
		}*/

	    console.log(inputs) 


		// reduce uses an accumulator: can't get it to work atm
		/*let all_weight = inputs.weight.reduce(
			(prev, curr) => {
				return prev + curr      
		}, 0)
		let mean_weight = all_weight / inputs.length
		console.log(all_weight)
		*/


	    let newdata = inputs.filter(function(client) { // filtering (not inplace)
	    	return client.height < 10
	    })

	    console.log(newdata.length)     // length of array
	    





	    

	    ///// section with bar fill length by height (changing the CSS bar pixel count to be between 0 and 300)
	    let contain_chart = d3.select('#contain_chart')

    	function showData_chart(inputs) {    // to display clients dict like file
			let max = d3.max(inputs,
		    	d => d.height)

		    let scale = d3.scaleLinear()
		    	.range([0, 300])
		    	.domain([0, max])

		    let join = contain_chart.selectAll('div')
		    	.data(inputs)

		    return join.enter()
		    	.append('div')
		    	.text(d => d.name + ' : ' + d.height)
		    	.style("background-color", "blue")
		    	.style('margin', '5px')
		    	.style('color', 'white')
		    	.style('width', d => scale(d.height))

			}
		//showData_chart(inputs)

		function write_chart() {    
			//contain_chart.append('div').text(text)
			showData_chart(inputs)
		}




		///// converting categories to pixel position, and sending to svg
		let contain_cats = d3.select('#contain_cats')

    	function showData_cats(inputs) {    // to display clients dict like file
			let max = d3.max(inputs,
		    	d => d.height)

		    let widthScale = d3.scaleLinear()
		    	.range([0, 300])
		    	.domain([0, max])

		    let positionScale = d3.scaleBand()
		    	.range([0, 200])                   // chart will be 200 px high
		    	.domain(inputs.map(d => d.name))   // taking names of inputs as category labels
		    	.padding(0.3)      // padding between bars

		    let join = contain_cats.selectAll('rect')
		    	.data(inputs)

		    join.enter()
		    	.append('rect')
		    	.attr('fill', 'blue')
		    	.attr('width', d => widthScale(d.height))
		    	.attr('height', positionScale.bandwidth())    // makes bars fill available space
		    	.attr('y', d => positionScale(d.name))


		    // making x labs using scaled values and positioning directly below chart
		    let xAxis = d3.axisBottom(widthScale)
		    	.ticks(6)
		    	.tickFormat(d => d + ' cm')     // add units to xlab
		    d3.select('#xAxis')
		    	.attr('transform', 'translate(50, 200)')
		    	.call(xAxis)

		    let yAxis = d3.axisLeft(positionScale)   // same for y axis
		    d3.select('#yAxis')
		    	.attr('transform', 'translate(50, 0)')
		    	.call(yAxis)


		    	// change what it returned

			}
		showData_cats(inputs)




		///// 



		




/*
	    let max = d3.max(inputs,
	    	d => d.height)

	    let scale = d3.scaleLinear()
	    	.range([0, 300])
	    	.domain([0, max])

	    let join = contain_chart.selectAll('div')
	    	.data(inputs)

	    join.enter()
	    	.append('div')
	    	.text(d => d.name + ' : ' + d.height)
	    	.style("background-color": "blue")
	    	.style('margin': '5px')
	    	.style('color': 'white')
	    	.style('width': '100')
*/








		let para1 = d3.select('p');
		para1.text("new text")     // this automatically updates the first para in the html, changing the text seen on page

		function change1() {
			let name = d3.select('#input_name');     // name isn't being read in from the input
			console.log(name);
			let header = d3.select('#pageheader');
			header.text("Welcome fool" + name)
		}

		function count() {  // getting number of items in list already
			return d3.select('#itemlist').selectAll('li').size()
		}

		function change2() {
			d3.select('#itemlist').
				append('li').              // creates new item of type li (list)
				text('Item' + count())     // populates new item with text
		}

		function change3() {
			d3.select('#itemlist').select('li:last-child').    // deletes last one in list
				remove()  
		}

		function change4() {
			d3.select('#itemlist').selectAll('li').
				remove()  
		}

		function change_welcome_col() {
			d3.select('#pageheader').style("color", "yellow")
		}

		function change_animal() {
			if (d3.select('#animalImg').attr('src') === 'cat.jpg') {   // similar syntax to get current source, as to update it
				d3.select('#animalImg').attr('src', 'doge.jpeg')
			} else {
				d3.select('#animalImg').attr('src', 'cat.jpg')
			}
		}




		let allparas = d3.selectAll('p');
		console.log(allparas.nodes())   // use "nodes" when there are multiple

		let header = d3.select('#pageheader');
		console.log(header.node())



		const pounds_to_kilos = 2.2;

		let client = {     // dict like single object, which func below uses
		name: 'adam',
		weight: 150,
		height: 180
		}

		 function get_weight_kilo(client) {
			let weight_kilo = client.weight / pounds_to_kilos;
			return weight_kilo
		}
			document.write(client.name + ": " + get_weight_kilo(client) + '<br>')       //shows value on website 


		// array of clients
		let client_array = [{     // dict like single object, which func below uses
		name: 'adam',
		weight: 150,
		height: 180
		}, 
		{     // dict like single object, which func below uses
		name: 'ans',
		weight: 130,
		height: 170
		}]

		// apply function to each dict in array
		for (let i = 0; i < client_array.length; i++) {
			let client = client_array[i];
			let weight_kilo = get_weight_kilo(client)
			if (weight_kilo > 60) {                       // only displaying above a certain threshold
				document.write(client.name + ": " + weight_kilo + '<br>') 
			}
		}



	</script>
		
</html>